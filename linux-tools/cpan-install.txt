Install CPAN Package Script (Unattended Install - Simplest Way)

?
PERL_MM_USE_DEFAULT=1 perl -MCPAN -e "install Bundle::CPAN"PERL_MM_USE_DEFAULT=1 perl -MCPAN -e "install XML::Simple"PERL_MM_USE_DEFAULT=1 perl -MCPAN -e "install Net::LDAP" 
Remove CPAN Package Script (Unattended Uninstall)

?
#!/usr/bin/perl -w use ExtUtils::Packlist;use ExtUtils::Installed; $ARGV[0] or die "Usage: $0 Module::Name\n"; my $module = $ARGV[0]; my $inst = ExtUtils::Installed->new(); foreach my $item (sort($inst->files($module))) {    print "Removing $item\n";    unlink $item;} my $packfile = $inst->packlist($module)->packlist_file();print "Removing $packfile\n";unlink $packfile; 
Install CPAN Package Script (Unattended Install)

?
#! /usr/bin/perl#use strict; if ( $^O =~ /win/i ) {    $ENV{TZ} = 'PST8PDT' unless $ENV{TZ} =~ /[CPAN Package Intallation and Remove Automation^\s]/;    $ENV{CYGWIN} .= ' nodosfilewarning'      unless $ENV{CYGWIN} =~ /nodosfilewarning/;} use warnings; ## Constants (begin)# After this number of days, use the 'force' option to# install all modulesmy $VERSION_VALID_DAYS = 60; # See http://mirrors.cpan.org/#my $CPAN_MIRRORS = 'http://mirrors1.kernel.org/pub/CPAN';my $CPAN_MIRRORS = 'http://ftp.yz.yamagata-u.ac.jp/pub/lang/cpan';my $CPAN_DIR     = dirname($^X) . '/.cpan_inst'; ### Constants (End) use Pod::Usage;use File::Basename;use Carp;use Getopt::Long;use File::Path qw(mkpath);use File::Temp qw(tempfile);use Cwd;use CPAN;    # This generates some interesting errors$Carp::Verbose = 1; #use Smart::Comments; my $automated     = 0;my $no_prompt     = 0;my $help          = 0;my $force         = 0;my $test          = 0;my $no_install    = 0;my $ignore_errors = 0;my $data_dir      = ''; &Getopt::Long::GetOptions(    'help|h'          => \$help,    'help2|?'         => \$help,    'no-prompt|P'     => \$no_prompt,    'automated|a'     => \$automated,    'force|f'         => \$force,    'test|t'          => \$test,    'no-install|I'    => \$no_install,    'ignore-errors|E' => \$ignore_errors,    'data-dir|d'      => \$data_dir,); if ($help) {    pod2usage( -verbose => 2, -exitval => 1, -noperldoc => 1 );    exit(1);} # See BUNDLES DATA STRUCTURE below## Change this version whenever you change @bundles# Increment the last number if the installer can pick up# from the last point. Changing any other number will# cause this script to attempt to install every module.my $VERSION = '1.11.0'; my @bundles = (     "Bundle::CPAN"  => {},    "XML::Simple"   => {},    "Net::LDAP"     => {}, ); my ( @all_modules, $version_fn, $log_fn, $stop_fn );my $first_bundle = 0;my $num_bundles  = ( 1 + $#bundles ) / 2; sub prompt {    my $prompt = !$automated;     if ( $prompt && !$_[0] ) {        $prompt = !$no_prompt;    }     unless ($prompt) { print "\n"; return; }     print "\nPress Enter to continue...\n";    <STDIN>;     return;} # Check Perl versionmy $perl_version = `"$^X" -v`;$perl_version =~ / (v[CPAN Package Intallation and Remove Automation^\s]+)/;$perl_version = $1;$perl_version =~ /v(\d+)\.(\d+)/;my ( $major, $minor ) = ( $1, $2 ); if ( $major < 5 ) {    print STDERR "Perl major version is $major. Must be 5 or greater. Exiting.";    prompt;    exit 1;} sub log_print {    my $f;    open( $f, ">>", $log_fn ) || croak 'Unable to open $version_fn - $!';    print $f ( scalar localtime() );    print $f @_;    print @_;    close $f;    return;} sub clear_version {    unlink $version_fn;    return;} sub check_progress {    if ( !$force && -e $version_fn ) {        my $f;        open( $f, "<", $version_fn ) || croak 'Unable to open $version_fn - $!';         if ( ( time - ( ( stat $f )[9] ) ) / ( 3600 * 24 ) >            $VERSION_VALID_DAYS )        {            $force = 1;        }        else {            my $ver = <$f>;            chomp $ver;             return unless $ver;             my ( $os, $perl_vers, $int );            ( $ver, $first_bundle, $os, $perl_vers, $int ) = split( /,/, $ver );             if (   $os                && $os eq $^O                && $perl_vers                && $perl_version eq $perl_vers                && $int                && $int eq $^X )            {                if ( $ver ne $VERSION ) {                    $ver =~ /\.(\d+)$/;                    my $last = $1;                    my $prev = $`;                    $VERSION =~ /\.(\d+)$/;                    $first_bundle = 0 unless $prev eq $` && ( $1 > $last );                }            }            else {                $first_bundle = 0;            }             if ($first_bundle) {                log_print "\n*** Resuming from previous run ***\n\n";                log_print "Version file: $version_fn\n";                log_print "Perl distribution: $os\n";                log_print "Perl interpreter: $int\n";                log_print "Perl version: $perl_vers\n";                log_print "Current script version: $VERSION\n";                log_print "Previous script version: $ver\n";                log_print                  "Number of modules previously installed: $first_bundle\n";                log_print "Number of modules to be installed: $num_bundles\n";            }        }    }     clear_version if $force;    return;} sub checkpoint {    my $f;     open( $f, ">", $version_fn ) || croak 'Unable to open $version_fn - $!';    print $f "$VERSION,$_[0],$^O,$perl_version,$^X\n";    close $f;    return;} sub std_path {    my $spec = $_[0];    $spec =~ s-\\-/-g;     my $prefix = q{};     if ( $spec =~ m-^/{2,}- ) {        $prefix = '//';        $spec   = $';    }    elsif ( $spec =~ /^[a-zA-Z]:+/ ) {    # Windows drive letter c:\        $prefix = substr( $&, 0, 2 );        $spec = $';    }     while (1) {        last if $spec eq q{};        last if $spec eq './';        last if $spec eq '.';        my $origspec = $spec;        $spec =~ s-^\./\.-.-;        next if $origspec ne $spec;        $spec =~ s-\.{3,}$-..-;        next if $origspec ne $spec;        $spec =~ s-([CPAN Package Intallation and Remove Automation^/\.])\.+$-$1-;        next if $origspec ne $spec;        $spec =~ s-/+\./+-/-g;        next if $origspec ne $spec;        $spec =~ s-([CPAN Package Intallation and Remove Automation^\.])\.$-$1-;    # foo.... -> foo        next if $origspec ne $spec;        $spec =~ s-([CPAN Package Intallation and Remove Automation^\.])\./-$1/-;    # foo./abc -> foo/abc        next if $origspec ne $spec;        $spec =~ s-/[CPAN Package Intallation and Remove Automation^\./]+/\.\.(/|$)-/-;    # ../a/../b -> ../b        next if $origspec ne $spec;          # ../a/.. -> ../        $spec =~ s-/{2,}-/-;        next if $origspec ne $spec;        $spec =~ s-([CPAN Package Intallation and Remove Automation^/\.])\./$-$1-;        next if $origspec ne $spec;        $spec =~ s-([CPAN Package Intallation and Remove Automation^/])/+$-$1-g;        last if $origspec eq $spec;    }     $prefix . $spec;} $0 = std_path($0);chdir dirname($0) || croak("chdir failed - $!"); my $extra_dir; if ($data_dir) {    $extra_dir = $data_dir;}else {    $extra_dir = cwd;     if ( basename(cwd) eq 'bin' ) {        $extra_dir = cwd . '/../var/log';    }    elsif ( basename(cwd) eq 'exec' ) {        $extra_dir = cwd . '/../../var/log';    }} mkpath($extra_dir) unless -d $extra_dir;croak "Unable to create $extra_dir" unless -d $extra_dir; $version_fn = "$extra_dir/install_perl_modules.dat";$log_fn     = "$extra_dir/install_perl_modules.log";$stop_fn    = "$extra_dir/install_perl_modules.stop"; log_print "Started on: " . scalar localtime() . "\n"; check_progress; if ( $first_bundle >= $num_bundles ) {    print "*** All modules are up to date ***\n";    print "Use the --force option to reinstall modules.\n";    prompt;    exit 110;} unless ($no_prompt) {    print "\nThis computer must have a live Internet connection.\n";     if ( $^O =~ /win/i ) {        print <<END This script must be run by a user in the local Administratorsgroup.END          ;    }    else {        print <<END This script must be run as root if you are modifying thesystem-wide perl installation. make and gcc++ must be installed. unixODBC-devel ora similar ODBC driver must be installed.END          ;    }     if ( $^O =~ /cygwin/ ) {        print <<END Required Cygwin modules:wget,perl,rebase,make,gcc=g++,gcc4-g++,readline,perl-libwin32 You must have read/write permissions to: $CPAN_DIR and the following Cygwin directories: /usr/lib/perl5,/lib/perl5,/usr/share/man,/usr/share/docEND          ;    }     prompt;} # Exit if there is no Internet connection#{    my $fn = $ENV{TEMP};    $fn = $ENV{TMP} unless $fn;    $fn = cwd       unless $fn;    $fn .= "/wget.$$";     print "\nTesting Internet connection...\n";     system( "wget", '--quiet', '-O', $fn, "http://w3c.org" );    unlink $fn;     if ($?) {        my $exit = $? >> 8;        if ( $exit eq 1 ) {            print STDERR "\nUnable to connect to the Internet. Exiting.\n";            prompt;            exit 1;        }        else {            log_print("\nwget not found. Unable to determine whether there is an Internet connection.\n"            );        }    }    else {        print "OK\n";    }} # This causes CPAN to take all defaults without input$ENV{PERL_MM_USE_DEFAULT} = 1; my ( $fh, $in_file );my $make  = 'make';my $shell = '/bin/bash'; if ( $^O =~ /Win/ ) {    $make = 'nmake';    my $sep = ';';    my $d   = cwd;    $d =~ s/\//\\/g;    $ENV{PATH} .= "${sep}$d";}else {    $ENV{TEMP}   = '/tmp';    $ENV{TMP}    = '/tmp';    $ENV{TMPDIR} = '/tmp';} ## Start loading modules#my $i          = $first_bundle * 2;my $successful = 1;my $exit_code  = 100; while ( !$test && $i < $#bundles && ( !-f $stop_fn ) ) {    my ( $bundle, $info ) = @bundles[ $i, $i + 1 ];    $i += 2;     log_print "\n*** $bundle ("      . ( $i / 2 )      . " of $num_bundles) [Begin] ***\n";     unless ($no_install) {         # Check constraints        #        next if $info->{'ignore'};        next if $info->{'windows'} && $^O !~ /win/i;         my $do_ppm = 0;         if ( !$info->{'cpan'} && $^O =~ /Win/ ) {    # If Windows..            ## ActivePerl            next if ( $bundle =~ /\.gz$/ ) || $info->{'no_activeperl'};            $do_ppm = 1;        }        else {            ## CPAN            next if $info->{'no_cpan'};            next if $info->{'manual_only'} && $automated;        }         if ( $info->{'ignore_if_after_5_9'} ) {            next if $major > 5 || ( $major == 5 && $minor > 9 );        }         if ( $info->{'ignore_if_before_5_10'} ) {            next if $major < 5 || ( $major == 5 && $minor < 10 );        }         ## Done with constraints        push( @all_modules, $bundle );         if ($do_ppm) {            my $bdl = $bundle;            $bdl =~ s/::/-/g;            system( 'ppm', 'install', $bdl );        }        else {            ## CPAN            ## Consult http://www.perl.com/doc/manual/html/lib/CPAN.html            log_print "\n*** " . $info->{'more'} . "\n***\n" if $info->{'more'};             if ( $bundle eq 'SHELL' ) {                system( $^X, '-MCPAN', '-e',                    'CPAN::Shell->o(\'conf\', \'init\')' );                 unless ($in_file) {                    ( $fh, $in_file ) = tempfile();                    close $fh;                }                 open( $fh, ">", $in_file ) || croak "open $in_file failed - $!";                 unless ( $^O =~ /Win/ ) {                    print $fh "o conf build_dir $CPAN_DIR\n";                    print $fh "o conf cpan_home $CPAN_DIR\n";                    print $fh "o conf keep_source_where $CPAN_DIR\n";                    print $fh "o conf prefs_dir $CPAN_DIR\n";                }                 print $fh "o conf shell $shell\n";                print $fh "o conf make_install_make_command $make\n";                 # See http://mirrors.cpan.org/                print $fh "o conf urllist $CPAN_MIRRORS\n";                print $fh "o conf commit\n";                 close $fh;                 no warnings;                open( SAVEIN, "<&STDIN" );                close STDIN;                open( STDIN, $in_file );                 system( $^X, '-MCPAN', '-e', 'shell' );                close STDIN;                open( STDIN, "<&SAVEIN" );            }             if ( $info->{'notest_if_after_5_9'} ) {                $info->{'normal'} = 1 if $major == 5 && $minor < 9;            }             # notest is the default            if (   $bundle ne 'SHELL'                && !$info->{'make'}                && !$info->{'force'}                && !$info->{'normal'} )            {                $info->{'notest'} = 1;            }             if ( $info->{'make'} ) {                unless ($in_file) {                    ( $fh, $in_file ) = tempfile();                    close $fh;                }                 open( $fh, ">", $in_file ) || croak "open $in_file failed - $!";                print $fh "\"$^X\" Makefile.PL\n$make\n$make install\n";                print $fh "\"$^X\" Build.PL\nperl Build install\n";                close $fh;                 no warnings;                open( SAVEIN, "<&STDIN" );                close STDIN;                open( STDIN, $in_file );                system( $^X, '-MCPAN', '-e',                    "CPAN::Shell->look( q{$bundle} )" );                close STDIN;                open( STDIN, "<&SAVEIN" );            }             if ( !$automated && $info->{'shell'} ) {                print "*** Manual intervention is required. Dropping into CPAN shell. ***";                system( $^X, '-MCPAN', '-e',                    "CPAN::Shell->look( q{$bundle} )" );            }             if ( $info->{'notest'} ) {                unless ($in_file) {                    ( $fh, $in_file ) = tempfile();                    close $fh;                }                 open( $fh, ">", $in_file ) || croak "open $in_file failed - $!";                print $fh "notest install $bundle\n";                close $fh;                 no warnings;                open( SAVEIN, "<&STDIN" );                close STDIN;                open( STDIN, $in_file );                system( $^X, "-MCPAN", "-e", "shell" );                close STDIN;                open( STDIN, "<&SAVEIN" );            }             if ( $info->{'normal'} || $info->{'force'} ) {                unless ($in_file) {                    ( $fh, $in_file ) = tempfile();                    close $fh;                }                 open( $fh, ">", $in_file ) || croak "open $in_file failed - $!";                 if ( $info->{'force'} ) {                    print $fh "force ";                }                print $fh "install $bundle\n\n";  # The second \n is intentional                 # The extra \n is there because Bundle::CPAN                # (specifically Term::ReadLine) asks the user                # to enter an expression                close $fh;                 no warnings;                open( SAVEIN, "<&STDIN" );                close STDIN;                open( STDIN, $in_file );                system( $^X, "-MCPAN", "-e", "shell" );                close STDIN;                open( STDIN, "<&SAVEIN" );            }        }    }     log_print "\n*** $bundle (" . ( $i / 2 ) . " of $num_bundles) [End] ***\n";     unless ( $info->{'no_verify'} ) {        my $mod = $info->{'module'};        $mod = $bundle unless $mod;         my $use = "use $mod;";        eval($use);         if ($@) {            $successful = 0;            $exit_code  = 10;            log_print "\n*** ERROR INSTALLING $bundle - $@\n";            last unless $ignore_errors;        }    }     checkpoint( $i / 2 );     # It is sometimes necessary to exit here to 'rebase' Cygwin    if (   ( $automated || $no_prompt )        && $i < $#bundles        && $^O =~ /cygwin/        && !$automated        && $bundles[ $i + 1 ]->{'exit_if_cygwin'} )    {        $exit_code = 50;        print"\n*** From the cygwin ash shell, run /bin/rebaseall and re-run this script ***\n";        last;    }} if ($in_file) {    close $fh;    unlink $in_file;} log_print "\nFinished on: " . ( scalar localtime() ) . "\n"; if ($successful) {    prompt;}elsif ( $exit_code == 10 ) {    # Force prompt on module installation failure    prompt(1);} exit $exit_code; __END__ 
